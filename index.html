<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Partikel Loading Screen - Advanced</title>
    <style>
        /* Grundlegendes Styling für Vollbild */
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden; /* Keine Scrollbalken */
            background-color: #050505; /* Sehr dunkler Hintergrund */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        /* Canvas (wo die 3D Grafik lebt) */
        canvas {
            display: block;
        }
        
        /* Ein kleiner Hinweis für den User */
        #hint {
            position: absolute;
            bottom: 30px;
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.3);
            pointer-events: none;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-size: 0.8rem;
        }
    </style>
</head>
<body>

    <div id="hint">Klicke für Explosion • Bewege die Maus</div>

    <!-- Einbindung von Three.js (der 3D Engine) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- KONFIGURATION ---
        const PARTICLE_COUNT = 4500; // Mehr Partikel für die größere Kugel
        const SPHERE_RADIUS = 250;   // Deutlich größer (war 100)
        const PARTICLE_SIZE = 2.2;   // Etwas dickere Punkte
        
        // --- SETUP ---
        const scene = new THREE.Scene();
        // Nebel etwas dichter und türkiser machen für mehr Atmosphäre
        scene.fog = new THREE.FogExp2(0x001111, 0.0015);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 3000);
        // Kamera Position angepasst, damit die riesige Kugel gut wirkt, aber den Screen füllt
        camera.position.z = 600;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // --- HAUPTKUGEL ---
        const sphereGeometry = new THREE.BufferGeometry();
        const spherePositions = [];
        const originalPositions = []; 
        
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const theta = THREE.MathUtils.randFloatSpread(360); 
            const phi = THREE.MathUtils.randFloatSpread(360); 
            const distance = SPHERE_RADIUS + Math.random() * 30 - 15; // Mehr Varianz in der Tiefe

            const x = distance * Math.sin(theta) * Math.cos(phi);
            const y = distance * Math.sin(theta) * Math.sin(phi);
            const z = distance * Math.cos(theta);

            spherePositions.push(x, y, z);
            originalPositions.push(x, y, z);
        }

        sphereGeometry.setAttribute('position', new THREE.Float32BufferAttribute(spherePositions, 3));
        
        const sphereMaterial = new THREE.PointsMaterial({ 
            color: 0x00ffff, // Reines Cyan/Türkis
            size: PARTICLE_SIZE,
            transparent: true,
            opacity: 0.9,
            blending: THREE.AdditiveBlending
        });

        const sphere = new THREE.Points(sphereGeometry, sphereMaterial);
        scene.add(sphere);

        // --- RINGE (Mehr davon!) ---
        const rings = []; // Array um alle Ringe zu speichern

        function createRing(radius, count, inclinationX, inclinationZ, opacity) {
            const ringGeo = new THREE.BufferGeometry();
            const ringPos = [];
            
            for(let i=0; i<count; i++) {
                const angle = (i / count) * Math.PI * 2;
                const r = radius + (Math.random() - 0.5) * 15;
                const x = Math.cos(angle) * r;
                const y = (Math.random() - 0.5) * 8;
                const z = Math.sin(angle) * r;
                ringPos.push(x, y, z);
            }
            ringGeo.setAttribute('position', new THREE.Float32BufferAttribute(ringPos, 3));
            
            const ringMat = new THREE.PointsMaterial({
                color: 0x40E0D0, // Türkis (Turquoise)
                size: 1.8,
                transparent: true,
                opacity: opacity,
                blending: THREE.AdditiveBlending
            });
            
            const ring = new THREE.Points(ringGeo, ringMat);
            ring.rotation.x = inclinationX;
            ring.rotation.z = inclinationZ;
            
            scene.add(ring);
            rings.push(ring); // Zum Animieren speichern
            return ring;
        }

        // 5 Ringe erstellen mit verschiedenen Größen und Neigungen
        createRing(320, 800, 0.2, 0.1, 0.6);
        createRing(380, 900, -0.4, 0.2, 0.5);
        createRing(450, 1000, 0.8, -0.3, 0.4);
        createRing(520, 1100, -0.6, -0.5, 0.3);
        createRing(600, 1200, 0.1, 0.8, 0.2); // Ganz außen

        // --- STERNENHIMMEL ---
        const starGeo = new THREE.BufferGeometry();
        const starPos = [];
        for(let i=0; i<3000; i++) { // Mehr Sterne
            const x = THREE.MathUtils.randFloatSpread(3000);
            const y = THREE.MathUtils.randFloatSpread(3000);
            const z = THREE.MathUtils.randFloatSpread(3000);
            starPos.push(x,y,z);
        }
        starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
        // Sterne auch leicht türkis anhauchen
        const starMat = new THREE.PointsMaterial({ color: 0x008888, size: 1.2, transparent: true, opacity: 0.3 });
        const starField = new THREE.Points(starGeo, starMat);
        scene.add(starField);

        // --- INTERAKTION ---
        let mouseX = 0;
        let mouseY = 0;
        let targetX = 0;
        let targetY = 0;
        let explosionPower = 0; // Wie stark ist die Explosion gerade?

        const windowHalfX = window.innerWidth / 2;
        const windowHalfY = window.innerHeight / 2;

        document.addEventListener('mousemove', (event) => {
            mouseX = (event.clientX - windowHalfX) * 0.5;
            mouseY = (event.clientY - windowHalfY) * 0.5;
        });

        // Klick-Event für Explosion
        document.addEventListener('mousedown', () => {
            explosionPower = 20; // Setzt Explosionskraft
        });

        // --- ANIMATION ---
        // Hue Variable entfernt, da wir festes Türkis wollen
        
        function animate() {
            requestAnimationFrame(animate);

            // Pulsierende Helligkeit statt Farbwechsel
            const time = Date.now() * 0.001;
            // Kugel leicht pulsieren lassen in der Farbe
            const sphereColorHSL = { h: 0.5, s: 1, l: 0.5 + Math.sin(time) * 0.1 }; 
            sphere.material.color.setHSL(0.5, 1, 0.5 + Math.sin(time * 2) * 0.1); // Cyan HSL ist 0.5

            // Mausbewegung glätten
            targetX = mouseX * 0.001;
            targetY = mouseY * 0.001;

            // Rotationen
            sphere.rotation.y += 0.002; // Langsamer da größer
            sphere.rotation.x += 0.0005;
            sphere.rotation.y += 0.03 * (targetX - sphere.rotation.y);
            sphere.rotation.x += 0.03 * (targetY - sphere.rotation.x);

            // Alle Ringe rotieren
            rings.forEach((ring, index) => {
                // Jeden Ring etwas anders drehen lassen
                const speed = 0.001 + (index * 0.0005);
                const direction = index % 2 === 0 ? 1 : -1;
                ring.rotation.y += speed * direction;
                ring.rotation.z += 0.0005 * direction;
            });

            // Hintergrund langsam drehen
            starField.rotation.y += 0.0001;

            // Explosion Logik
            // Wenn Power da ist, fliegen Partikel nach außen. Wenn nicht, kehren sie zurück.
            const positions = sphere.geometry.attributes.position.array;
            
            // Explosion dämpfen
            if (explosionPower > 0) {
                explosionPower *= 0.94; 
                if(explosionPower < 0.1) explosionPower = 0;
            }

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const ix = i * 3;
                const iy = i * 3 + 1;
                const iz = i * 3 + 2;

                let tx = originalPositions[ix];
                let ty = originalPositions[iy];
                let tz = originalPositions[iz];

                if (explosionPower > 0) {
                    const blast = 1 + (explosionPower * 0.3); // Stärkere Explosion für größere Kugel
                    positions[ix] += (tx * blast - positions[ix]) * 0.1;
                    positions[iy] += (ty * blast - positions[iy]) * 0.1;
                    positions[iz] += (tz * blast - positions[iz]) * 0.1;
                } else {
                    positions[ix] += (tx - positions[ix]) * 0.05;
                    positions[iy] += (ty - positions[iy]) * 0.05;
                    positions[iz] += (tz - positions[iz]) * 0.05;
                }
            }
            sphere.geometry.attributes.position.needsUpdate = true;

            // Pulsieren (Größe)
            const scale = 1 + Math.sin(time * 0.5) * 0.03; // Langsameres, wuchtigeres Pulsieren
            sphere.scale.set(scale, scale, scale);

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>
</html>
